var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Chordal","category":"page"},{"location":"#Chordal","page":"Home","title":"Chordal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Chordal]","category":"page"},{"location":"#Chordal.build_A-Union{Tuple{S}, Tuple{T}, Tuple{Vector{JuMP.VariableRef}, AbstractArray{SparseArrays.SparseMatrixCSC{T, S}, 1}, SparseArrays.SparseMatrixCSC{T, S}}} where {T<:Number, S<:Integer}","page":"Home","title":"Chordal.build_A","text":"build_A(y::Vector{JuMP.VariableRef}, F::AbstractVector{SparseMatrixCSC{T, S}}, G::SparseMatrixCSC{T, S}) where {T <: Number, S <: Integer}\n\nBuilds a JuMP.GenericAffExpr A = F_1 y_1 + F_2 y_2 + ... + F_n y_n + G.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.build_constraints_lmi!-Tuple{JuMP.Model, SparseArrays.SparseMatrixCSC{JuMP.AffExpr, Int64}}","page":"Home","title":"Chordal.build_constraints_lmi!","text":"build_constraints_lmi!(m::JuMP.Model, A::SparseMatrixCSC{JuMP.AffExpr, Int}; verbose=false)\n\nAdds the constraint A + S ∈ PSDCone(), where S ⪰ 0 to JuMP model m\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.build_constraints_lmi!-Union{Tuple{S}, Tuple{T}, Tuple{JuMP.Model, Vector{JuMP.VariableRef}, AbstractArray{SparseArrays.SparseMatrixCSC{T, S}, 1}, SparseArrays.SparseMatrixCSC{T, S}}} where {T<:Number, S<:Integer}","page":"Home","title":"Chordal.build_constraints_lmi!","text":"build_constraints_lmi!(m::JuMP.Model, A::SparseMatrixCSC{JuMP.AffExpr, Int}; verbose=false)\n\nAdds the constraint F_1 y_1 + F_2 y_2 + ... + F_n y_n + G ∈ PSDCone() to JuMP model m\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.build_perm_matrix-Tuple{Any}","page":"Home","title":"Chordal.build_perm_matrix","text":"build_perm_matrix(p)\n\nBuilds a sparse permutation matrix form permutation p such that P*x == x[p]\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.generate_clique_graph-Tuple{Any, Integer}","page":"Home","title":"Chordal.generate_clique_graph","text":"generate_clique_graph(cliques, n::Integer)\n\nGenerates CliqueGraph datastructure for an undirected graph from cliques and the number of nodes n.\n\nReference\n\nA clique graph based merging strategy for decomposable SDPs by Michael Garstka, Mark Cannon, Paul Goulart\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.generate_clique_tree-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv<:AbstractFloat, Ti<:Integer}","page":"Home","title":"Chordal.generate_clique_tree","text":"generate_clique_tree(A::SparseMatrixCSC{Tv, Ti}) where {Tv <: AbstractFloat, Ti <: Integer}\n\nGenerates a CliqueTree from chordally sparse matrix A.\n\nReference\n\n[VA15] Chordal Graphs and Semidefinite Optimization by Lieven Vandenberghe and Martin Andersen\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.generate_random_sdp-Tuple{Any}","page":"Home","title":"Chordal.generate_random_sdp","text":"generate_random_sdp(n; rand_seed=0)\n\nGenerates a random dual form SDP with side dimension n: min c'*x s.t. sum(F[i]*x[i]) + G ⪰ 0\n\nReturns c, F, G, xstar, D, where xstar and D are optimal primal and dual variables respectively\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_children_from_par-Tuple{Vector{Int64}}","page":"Home","title":"Chordal.get_children_from_par","text":"get_children_from_par(par)\n\nCompute the children of each vertex v in a tree specified by par\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_chordal_extension-Tuple{SparseArrays.SparseMatrixCSC}","page":"Home","title":"Chordal.get_chordal_extension","text":"get_chordal_extension(sp_pattern::SparseMatrixCSC; perm=\"amd\", verbose=false)\n\nReturns p, ip, L, where L is a lower-triangular matrix representing the chordal extension of the undirected graph sp_pattern after fill-reducing permutation p (with inverse permutation ip).\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_cliques-Tuple{Chordal.CliqueGraph}","page":"Home","title":"Chordal.get_cliques","text":"get_cliques(cg::CliqueGraph)\n\nReturns a list of the cliques in CliqueGraph cg.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_cliques-Tuple{Chordal.CliqueTree}","page":"Home","title":"Chordal.get_cliques","text":"get_cliques(ct::CliqueTree)\n\nReturns the cliques in the graph represented by CliqueTree ct.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_cliques-Tuple{SparseArrays.SparseMatrixCSC}","page":"Home","title":"Chordal.get_cliques","text":"get_cliques(L::SparseMatrixCSC)\n\nReturns the (maximal) cliques of the undirected graph represented by lower triangular matrix L.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_etree-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv<:AbstractFloat, Ti<:Integer}","page":"Home","title":"Chordal.get_etree","text":"get_etree(A)\n\nCompute the parent function of the elimination tree of a symmetric sparse matrix A\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_higher_deg-Tuple{SparseArrays.SparseMatrixCSC}","page":"Home","title":"Chordal.get_higher_deg","text":"get_higher_deg(L::SparseMatrixCSC)\n\nReturns the higher degrees of each node in the graph represented by lower triangular matrix L.\n\nNOTE: the algorithm assums that L has order σ = 1:n and zeros on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_postordering-Tuple{Any, Any}","page":"Home","title":"Chordal.get_postordering","text":"get_postordering(par, child)\n\nGets a postordering of the tree represented by vector of parents par and vector of children child.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_selectors-Tuple{SparseArrays.SparseMatrixCSC}","page":"Home","title":"Chordal.get_selectors","text":"get_selectors(input_mat::SparseMatrixCSC; verbose=true, ret_cliques=true)\n\nReturns the (merged) cliques of the graph corresponding to the sparsity pattern of input_mat (after a permutation to reduce fill-in) and optionally the cliques. Also returns the fill-reducing permutation and and inverse permutation used.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.get_sparsity_pattern_from_cliques-Tuple{Any}","page":"Home","title":"Chordal.get_sparsity_pattern_from_cliques","text":"get_sparsity_pattern_from_cliques(cliques)\n\nReturns a sparse matrix sp corresponding to the graph with maximal cliques cliques\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.is_chordal-Tuple{SparseArrays.SparseMatrixCSC}","page":"Home","title":"Chordal.is_chordal","text":"is_chordal(A)\n\nTests if the graph represented by symmetric sparse matrix A is chordal. This function can also be used with AbstractGraph objects from LightGraphs.jl.\n\nReferences\n\nSimple linear-time algorithms to test chordality of graphs, test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs by Robert Tarjan and Mihalis Yannakakis\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.is_separable-Tuple{SparseArrays.SparseMatrixCSC}","page":"Home","title":"Chordal.is_separable","text":"is_separable(sp::SparseMatrixCSC)\n\nReturns true if the sparsity pattern is separable (i.e., block diagonal).\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.make_selectors_from_clique_graph-Tuple{Chordal.CliqueGraph, Any}","page":"Home","title":"Chordal.make_selectors_from_clique_graph","text":"make_selectors_from_clique_graph(cg::CliqueGraph, n)\n\nBuilds selector matrices Tℓ from cg, a CliqueGraph with n vertices.\n\nTℓ*X*Tℓ' is the submatrix of X corresponding to clique ℓ.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.make_selectors_from_cliques-Tuple{Any, Any}","page":"Home","title":"Chordal.make_selectors_from_cliques","text":"make_selectors_from_cliques(cliques, n)\n\nBuilds selector matrices Tℓ from cliques, a list of the cliques in a graph with n vertices.\n\nTℓ*X*Tℓ' is the submatrix of X corresponding to clique ℓ.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.max_supernode_etree-Tuple{SparseArrays.SparseMatrixCSC, Vector{Int64}}","page":"Home","title":"Chordal.max_supernode_etree","text":"max_supernode_etree(L::SparseMatrixCSC, etree_par::Vector{Int})\n\nConstructs the supernodal elimination tree of the chordal graph represented by lower triangular matrix L and with elimination tree etree_par. Returns the reprsentation vertices, the supernodal elimination tree, and a supernode memership indicator.\n\nImplemented using [VA15, Algorithm 4.1], which was originally formulated by [PS89].\n\nReferences\n\n[PS89] Compact clique tree data structures in sparse matrix factorizations by Alex Pothen and Chunguang Sun\n[VA15] Chordal Graphs and Semidefinite Optimization by Lieven Vandenberghe and Martin Andersen\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.maxdet_completion-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv<:AbstractFloat, Ti<:Integer}","page":"Home","title":"Chordal.maxdet_completion","text":"maxdet_completion(A::SparseMatrixCSC{Tv, Ti}) where {Tv <: AbstractFloat, Ti <: Integer}\n\nReturns the maximum determinant completion of chordal sparse matrix A using Algorithm 10.2 in [VA15].\n\n#Reference [VA15] Chordal Graphs and Semidefinite Optimization by Lieven Vandenberghe and Martin Andersen\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.maxdet_completion_etree-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv<:AbstractFloat, Ti<:Integer}","page":"Home","title":"Chordal.maxdet_completion_etree","text":"maxdet_completion_etree(A::SparseMatrixCSC{Tv, Ti}) where {Tv <: AbstractFloat, Ti <: Integer}\n\nReturns the cholesky factors of the inverse of the maximum determinant completion of chordal sparse matrix A using Algorithm 4.2 in [ADV14]. This algorithm uses the elimination tree of A and, therefore, BLAS level 2 operations.\n\n#Reference [ADV12] Logarithmic barriers for sparse matrix cones by Martin S. Andersen, Joachim Dahl, Lieven Vandenberghe\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.maxdet_completion_factors-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv<:AbstractFloat, Ti<:Integer}","page":"Home","title":"Chordal.maxdet_completion_factors","text":"maxdet_completion_etree(A::SparseMatrixCSC{Tv, Ti}) where {Tv <: AbstractFloat, Ti <: Integer}\n\nReturns the cholesky factors of the inverse of the maximum determinant completion of chordal sparse matrix A using Algorithm 7.3 in [ADV14]. This algorithm uses the supernodal elimination tree of A and, therefore, BLAS level 3 operations.\n\n#Reference [ADV12] Logarithmic barriers for sparse matrix cones by Martin S. Andersen, Joachim Dahl, Lieven Vandenberghe\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.maximum_cardinality_search-Tuple{SparseArrays.SparseMatrixCSC}","page":"Home","title":"Chordal.maximum_cardinality_search","text":"maximum_cardinality_search(A)\n\nCompute the perfect elimination ordering for a chordal graph represented by a symmetric sparse matrix A. This function can also be used with AbstractGraph objects from LightGraphs.jl.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.merge_cliques!-Tuple{Chordal.CliqueGraph}","page":"Home","title":"Chordal.merge_cliques!","text":"merge_cliques!(cg::CliqueGraph; verbose=false)\n\nMerges cliques in cg in a greedy fashion starting with the pair with the largest weight_function. Stops when all pairs of cliques have a non-positive weight.\n\nReference\n\nA clique graph based merging strategy for decomposable SDPs by Michael Garstka, Mark Cannon, Paul Goulart\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.order_snds!-Tuple{Chordal.CliqueTree}","page":"Home","title":"Chordal.order_snds!","text":"order_snds!(ct::CliqueTree)\n\nOrders supernodes such that elements of each supernode are numbered consecutively and the order is a topological ordering of the reprsentative vertices in the supernodal elimination tree. (See [VA15, 4.6])\n\nReference\n\n[VA15] Chordal Graphs and Semidefinite Optimization by Lieven Vandenberghe and Martin Andersen\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.preprocess!-Union{Tuple{SparseArrays.SparseMatrixCSC{T, var\"#s2\"} where var\"#s2\"<:Integer}, Tuple{T}} where T","page":"Home","title":"Chordal.preprocess!","text":"preprocess!(mat::SparseMatrixCSC{T, <:Integer}) where {T}\n\nChecks that mat is symmetric and drops numerical zeros.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.reconstruct_from_sparse_varref-Tuple{Any, Any}","page":"Home","title":"Chordal.reconstruct_from_sparse_varref","text":"reconstruct_from_sparse_varref(Zref, n)\n\nGets the value of JuMP.Containers.SparseAxisArray Zref and returns the result as a SparseMatrixCSC\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.sparsity_pattern-Union{Tuple{AbstractArray{SparseArrays.SparseMatrixCSC{T, S}, 1}}, Tuple{S}, Tuple{T}} where {T, S<:Integer}","page":"Home","title":"Chordal.sparsity_pattern","text":"sparsity_pattern(mats::AbstractVector{SparseMatrixCSC{T,S}}) where {T, S <: Integer}\n\nReturns the 0/1 aggregate sparsity pattern of the matrices in mats as a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.unzip-Tuple{Any}","page":"Home","title":"Chordal.unzip","text":"unzip(a)\n\nUnzips a list of tuples a.\n\nExample\n\njulia> unzip([(1,2), (3,4), (5,6)])\n([1, 3, 5], [2, 4, 6])\n\n\n\n\n\n","category":"method"},{"location":"#Chordal.weight_function-Tuple{Any, Any}","page":"Home","title":"Chordal.weight_function","text":"weight_function(ci, cj)\n\nDefines the weight function used to determine if cliques ci and cj should be merged. Cliques are merged if this is positive.\n\nReference\n\nA clique graph based merging strategy for decomposable SDPs by Michael Garstka, Mark Cannon, Paul Goulart\n\n\n\n\n\n","category":"method"}]
}
